As you complete your work on this assignment, you must maintain an
assignment diary where you will reflect on what you have done. In a text
file called assn2Diary.txt, place the date and time of your work
together with some brief comments of the work you have completed such as
what you worked on, what you accomplished and what bugs you fixed.

You should discuss your choices of data structures and additional ADTs
you have used in your implementation. It should also discuss how you
have tested your implementation.

You may like to base your assignment diary on logs from a version
control system, like Git or Subversion. Make sure your commit messages
are informative!


##Jan 14 2017
Set up assign2 git repository, set up assign2Diary.txt
Create branch 'task0' for Task0
Add testGraph.c to branch task0

##Jan 15-20 2017
Add more test cases to task0
Read spec and lecture slides to understand graph's implementation
Research and design the graph representation struct

##Jan 21 2017
Consolidate Graph theory and implementation
Understand each representation pros and cons

Apply the optimised 2d array graph representation for assignment2
Go through the graph.c and implement graph init function

>>Reasons for 2D array representation:
The map of city is weighted graph, it is easy record the weight of each
edge.
Adapt the optimised 2D array because the graph is undirected graph, it
can be stored only once in triangle matrix.


##Jan 22 2017
Finish Graph.c basic function prototype

##Jan 25 2017
More understanding for dfs and bfs and find shortest path from lab6
Study lab6 test data so as to understand different search strategies

##Jan 26 2017
Complete testGraph.c
add invalid test cases
Refactor Graph.c prototype to handle invalid params

##Jan 27 2017
Start to implement Agent.c and Agent.h
Complete stage0
Start stage0 for task2
>> Tasks to complete:
 1) Each vertex(city) has a name, which is scanned in by the program.
amend the graph struct to contain this informantion so as to retain when
user check the status of the game.
 2) Each vertex(city) might has an informant, which is scanned in by the program.
amend the graph struct to contain this informantion so as to retain when
user check the status of the game or step the game.
 3) Make sure all the information shown in stats and map have all the
correct details.
 4) Stamina limitations and move weight reduction and stamina reset
implementation
 5) Comply Winning and Losing Rules:
* The detectives win the game if at the end of the turn, they are
located in the same city as the thief.
* The thief wins the game if at the end of a turn they is located in the
goal city and there are no detectives there.
* If the thief reaches the goal location at the same time as one of the
detectives, the detective catches the thief and wins.

##Jan 28 2017
Finish stage 0 of task2
 1) Refactor graphRep(informants, names), agent(destination) struct to
contain extra information
 2) Add methods to these header file:
Agent.h
  void setDestination(Agent a, int end);
  Vertex getDestination(Agent agent);
Graph.h
  char * hasInformant(int city); // check if the city has informant
  void readCityInfo(int city, char info,char * name); // read std io for each city info
  char * getCityName(int city); // fetch city's name
 3) Implement those methods in the each c files.
 4) Amend main.c to achieve below:
 * Amend readGraph methods to set informant and name
 * Amend initialiseAgents function to set THIEF destination
 * Amend display method to display informant if detective encounters
 * Refactor checkGameState function to implement winning and losing the
   game.
 5) Amend Agent.c to achieve below:
 * Add print destination logic in printAgent method to print thief
   goal city

TO-DD :
1) Stage 1: CHEAPEST_LEAST_VISITED strategy
2) Stage 2: DFS strategy


##Jan 29 2017
* Finish stage 1 & stage 2 of task2
Problem encounting:
1. for stage 1, first attemp is to quick sort and merge sort those
filtered moves based on less visited times, however quicksort is not a
stable sort plus each move are sorted based on weight and end vertex if
the visited times are tied. However all we need is 1 move from the
filtered moves.
Hence my solution:
Visited times is recorded by int visit[], and all the filteredMoves is
an array too therefore I mark the least index then compare the visited
times and weight also the id of those filteredMoves update the least
index along the comparisons.

2. for stage 2, I give the path array to agent struct. Thus DFS has
implementation will work out those vertices visit order in agent->visit
array(use this same field for different strategy). So detective have the
plan(order) to visit all the vertices. Also the vertices in the path
array to form the next move.
However I miss the point that those ordered visit vertices might be not
adjacent, therefore it can't form a path to next vertex.

>>problems I got to solve for this situation:
1 . firstly I need to check the next vertex and the current location is
adjacent. that means if there is move to form.
2. if it is not adjacent, we need to remember this next move as well as
go back to the last location.
3. how can backtrack also find the vertex has a path to
next unvisited vertex.

Hence my solution:
1. get next visit vertex and check if it is adjacent to the current
location.
2. if not, swap the unvisit with the current spot in the path array; and
update next visit vertex to the last visited vertex;
(this swap will update the next proper move in the paths array;
therefore it can stop it go forward again and only go back till it check
that is adjacent next unvisited vertex also because for this strategy
agent will use the visit array to recode the visit order so it will move
to the updated next move in the path array, once it find the adjacent
Vertex to the next unvisited vertex.
3. form the path with the proper vertex.

TO-DD : Stage 3: Least Turns Path Strategy
1) understand the implement logic and research one Dijkstra algorithms.
2) amend print destination to print out agent's goal city
3) add logic for set detective destination once they encounter informant

30 Jan 2017
review the sorting and bfs and dfs as well as the dijkstra algorithms
for stage 3

31 Jan 2017
Try to implement Diijstrak and bfs for the stage 3
First attemp, I was thinking all we care about the shortest paths


5 Feb 2017





- track what your current stamina is
- for every outgoing edge:
- if not enough stamina, add the cost of resting to the weight
done

